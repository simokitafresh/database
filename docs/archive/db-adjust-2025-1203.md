# 価格調整検出・自動修正機能 設計書（2025-12-03更新版）

## 概要

本ドキュメントは、株価データの調整（配当・分割等）を検出し、自動修正する機能の設計をまとめたものです。

---

## 1. 背景と課題

### 1.1 現状の問題

```
┌─────────────────────────────────────────────────────────────┐
│  現在のデータ取得フロー                                      │
├─────────────────────────────────────────────────────────────┤
│  1. yfinance API (auto_adjust=True)                         │
│     → 取得時点での調整済み価格を取得                         │
│                                                             │
│  2. DBにUPSERT                                              │
│     → 取得時点の調整済み価格として保存                       │
│                                                             │
│  3. 直近7日リフレッチ (YF_REFETCH_DAYS=7)                   │
│     → 直近7日分のみ再取得して上書き                         │
│                                                             │
│  【問題】7日超の古いデータは更新されない                     │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 価格乖離の実例（AAPL）

| 日付 | DB値 | YF調整済 | 乖離率 | 原因 |
|------|------|----------|--------|------|
| 2025-11-20 | 266.25 | 266.25 | 0.00% | 最新 |
| 2024-11-07 | 227.48 | 226.21 | 0.56% | 配当1回分 |
| 2024-01-02 | 185.64 | 183.90 | 0.94% | 配当数回分 |
| 2023-01-03 | 125.07 | 123.21 | 1.51% | 約1年分の配当 |
| 1990-01-02 | 0.33 | 0.26 | 27.45% | 35年分の累積 |

### 1.3 なぜ問題か

1. **バックテストの信頼性低下**: 誤った価格での検証
2. **リターン計算の誤差**: 長期投資で年1-2%の累積誤差
3. **リスク指標の不正確さ**: ボラティリティ、シャープレシオ等

---

## 2. 検出対象イベント

### 2.1 SUPPORTED_EVENTS（必須）

| イベントタイプ | 説明 | 価格影響 | yfinance取得 | 検出方法 |
|---------------|------|----------|--------------|----------|
| `stock_split` | 株式分割 | 50-90%減 | ✅ `ticker.splits` | 乖離率 ≥10% |
| `reverse_split` | 逆分割 | 100-900%増 | ✅ `ticker.splits` (ratio<1) | 乖離率 ≥10% |
| `dividend` | 通常配当 | 0.1-0.5%/回 | ✅ `ticker.dividends` | 乖離率 ≥0.001% |
| `special_dividend` | 特別配当 | 1-5% | ✅ `ticker.dividends` (異常値) | 乖離率 ≥2% |
| `capital_gain` | キャピタルゲイン分配（ETF） | 0.1-1% | ⚠️ `ticker.capital_gains` | 乖離率 ≥0.1% |
| `spinoff` | スピンオフ | 10-30% | ❌ 直接取得不可 | 乖離率 ≥15% + 分割なし |

### 2.2 検出閾値

```python
THRESHOLDS = {
    "float_noise_pct": 0.0001,      # 浮動小数点ノイズ（無視）
    "min_detection_pct": 0.001,     # 最小検出閾値
    "split_threshold_pct": 10.0,    # 分割判定閾値
    "special_div_threshold_pct": 2.0,  # 特別配当判定閾値
    "spinoff_threshold_pct": 15.0,  # スピンオフ判定閾値
}
```

---

## 3. 修正フロー

### 3.1 基本フロー

```
┌─────────────────────────────────────────────────────────────┐
│  価格調整 検出・修正フロー                                   │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 定期スキャン（週次 or 日次）                            │
│     - DBの過去価格 vs yfinance最新調整済み価格を比較        │
│     - サンプルポイント: 10点（等間隔）                      │
│                                                             │
│  2. 乖離検出                                                │
│     - 閾値: 0.001%以上で検出                               │
│     - イベント分類: 分割/配当/スピンオフ等                  │
│                                                             │
│  3. イベント記録（corporate_events テーブル）               │
│     - status = 'detected'                                   │
│     - 検出情報（乖離率、価格差等）を保存                    │
│                                                             │
│  4. 修正実行                                                │
│     a) 該当銘柄の prices を【全削除】                       │
│     b) fetch_job を作成して【全期間再取得】                 │
│     c) corporate_events.status = 'fixed'                   │
│                                                             │
│  5. 検証                                                    │
│     - 再取得後の乖離率 < 0.0001% を確認                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 なぜ「上書き」ではなく「削除→再取得」か

| 方式 | メリット | デメリット |
|------|----------|------------|
| UPSERT（上書き） | 差分のみで高速 | 存在しない日付の行が残る可能性 |
| **DELETE→INSERT** | 確実にクリーン | 全件再取得で時間がかかる |

**採用**: DELETE→INSERT 方式（データ整合性を優先）

---

## 4. データベース設計

### 4.1 新規テーブル: `corporate_events`

```sql
CREATE TABLE corporate_events (
    -- 主キー
    id SERIAL PRIMARY KEY,
    
    -- イベント識別
    symbol VARCHAR(20) NOT NULL,
    event_date DATE NOT NULL,
    event_type VARCHAR(30) NOT NULL CHECK (event_type IN (
        'stock_split',
        'reverse_split', 
        'dividend',
        'special_dividend',
        'capital_gain',
        'spinoff',
        'unknown'
    )),
    
    -- イベント詳細
    ratio NUMERIC(10, 6),              -- 分割比率 (4:1 → 4.0)
    amount NUMERIC(12, 4),             -- 配当額
    currency VARCHAR(3) DEFAULT 'USD',
    ex_date DATE,                      -- 権利落ち日
    
    -- 検出情報
    detected_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    detection_method VARCHAR(20) DEFAULT 'auto',
    db_price_at_detection NUMERIC(12, 4),
    yf_price_at_detection NUMERIC(12, 4),
    pct_difference NUMERIC(8, 6),
    severity VARCHAR(10) CHECK (severity IN ('critical', 'high', 'normal', 'low')),
    
    -- 修正情報
    status VARCHAR(20) DEFAULT 'detected' CHECK (status IN (
        'detected',      -- 検出済み（未修正）
        'confirmed',     -- 確認済み（修正待ち）
        'fixing',        -- 修正中
        'fixed',         -- 修正完了
        'ignored',       -- 無視（誤検出等）
        'failed'         -- 修正失敗
    )),
    fixed_at TIMESTAMPTZ,
    fix_job_id VARCHAR(50),            -- fetch_jobs.job_id への参照
    rows_deleted INTEGER,
    rows_refetched INTEGER,
    
    -- メタデータ
    source_data JSONB,                 -- yfinanceからの生データ
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- 制約
    CONSTRAINT fk_corp_events_symbol FOREIGN KEY (symbol) 
        REFERENCES symbols(symbol) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT uq_corp_event UNIQUE (symbol, event_date, event_type)
);

-- インデックス
CREATE INDEX idx_corp_events_symbol ON corporate_events(symbol);
CREATE INDEX idx_corp_events_date ON corporate_events(event_date DESC);
CREATE INDEX idx_corp_events_type ON corporate_events(event_type);
CREATE INDEX idx_corp_events_status ON corporate_events(status) WHERE status != 'fixed';
CREATE INDEX idx_corp_events_detected ON corporate_events(detected_at DESC);
```

### 4.2 テーブルの役割

| 目的 | 説明 |
|------|------|
| **履歴管理** | いつ何が起きたか完全に追跡可能 |
| **重複防止** | UNIQUE制約で同じイベントを二重処理しない |
| **監査証跡** | 修正前の価格・影響行数を記録 |
| **分析基盤** | 配当カレンダー、分割履歴の照会が可能 |
| **ETL連携** | 消費者側で権利落ち日を考慮した処理が可能 |

---

## 5. API設計

### 5.1 既存エンドポイント（実装済み）

| メソッド | パス | 説明 |
|----------|------|------|
| `POST` | `/v1/maintenance/check-adjustments` | 調整チェック実行 |
| `GET` | `/v1/maintenance/adjustment-report` | 最新レポート取得 |
| `POST` | `/v1/maintenance/fix-adjustments` | 検出シンボルを修正 |
| `POST` | `/v1/adjustment-check` | Cron用（認証必要） |

### 5.2 新規エンドポイント（corporate_events用）

| メソッド | パス | 説明 |
|----------|------|------|
| `GET` | `/v1/events` | 全イベント一覧（ページネーション） |
| `GET` | `/v1/events/{symbol}` | 銘柄別イベント履歴 |
| `GET` | `/v1/events/pending` | 未処理イベント一覧 |
| `GET` | `/v1/events/dividends` | 配当カレンダー |
| `GET` | `/v1/events/splits` | 分割履歴 |
| `POST` | `/v1/events/{id}/confirm` | イベント確認 |
| `POST` | `/v1/events/{id}/ignore` | 誤検出として無視 |

### 5.3 レスポンス例

#### GET /v1/events/AAPL

```json
{
  "symbol": "AAPL",
  "events": [
    {
      "id": 123,
      "event_date": "2024-11-07",
      "event_type": "dividend",
      "amount": 0.25,
      "currency": "USD",
      "status": "fixed",
      "detected_at": "2024-11-08T03:00:00Z",
      "fixed_at": "2024-11-08T03:15:00Z",
      "pct_difference": 0.56,
      "rows_refetched": 11023
    },
    {
      "id": 98,
      "event_date": "2020-08-31",
      "event_type": "stock_split",
      "ratio": 4.0,
      "status": "fixed",
      "detected_at": "2020-09-01T03:00:00Z",
      "fixed_at": "2020-09-01T03:30:00Z",
      "pct_difference": 75.0,
      "rows_refetched": 10200
    }
  ],
  "total": 2
}
```

---

## 6. 実装計画

### 6.1 フェーズ

| Phase | 内容 | 工数 | 優先度 |
|-------|------|------|--------|
| 1 | `corporate_events` テーブル作成（マイグレーション） | 0.5日 | 🔴 高 |
| 2 | モデル定義 (`app/db/models.py`) | 0.5日 | 🔴 高 |
| 3 | スキーマ定義 (`app/schemas/events.py`) | 0.5日 | 🔴 高 |
| 4 | `adjustment_detector.py` 更新（検出時にテーブル記録） | 1日 | 🔴 高 |
| 5 | `adjustment_fixer.py` 更新（修正時にステータス更新） | 0.5日 | 🔴 高 |
| 6 | イベントAPI実装 (`app/api/v1/events.py`) | 1日 | 🟡 中 |
| 7 | ドキュメント更新 | 0.5日 | 🟡 中 |
| **合計** | | **4.5日** | |

### 6.2 ファイル構成（予定）

```
app/
├── db/
│   └── models.py                 # CorporateEvent モデル追加
├── schemas/
│   └── events.py                 # 新規作成
├── services/
│   ├── adjustment_detector.py    # 検出時にテーブル記録
│   └── adjustment_fixer.py       # 修正時にステータス更新
├── api/v1/
│   └── events.py                 # 新規作成
└── migrations/versions/
    └── xxxx_create_corporate_events.py  # 新規作成
```

---

## 7. 運用フロー

### 7.1 日次/週次の自動処理

```
┌─────────────────────────────────────────────────────────────┐
│  Cron Job: /v1/adjustment-check                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 全アクティブ銘柄をスキャン                              │
│                                                             │
│  2. 乖離検出 → corporate_events に INSERT                  │
│     (status = 'detected')                                   │
│                                                             │
│  3. auto_fix=true の場合:                                   │
│     - critical/high イベントは即時修正                      │
│     - prices 削除 → fetch_job 作成                         │
│     - status = 'fixed'                                     │
│                                                             │
│  4. auto_fix=false の場合:                                  │
│     - レポートのみ生成                                      │
│     - 管理者が手動で確認・修正                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 7.2 手動確認フロー

```
1. GET /v1/events/pending で未処理イベント確認
2. イベント内容を確認
3. POST /v1/events/{id}/confirm で承認
   または POST /v1/events/{id}/ignore で無視
4. POST /v1/maintenance/fix-adjustments で修正実行
```

---

## 8. 設定項目

```python
# app/core/config.py

# 調整検出設定
ADJUSTMENT_CHECK_ENABLED: bool = True
ADJUSTMENT_MIN_THRESHOLD_PCT: float = 0.001
ADJUSTMENT_SAMPLE_POINTS: int = 10
ADJUSTMENT_MIN_DATA_AGE_DAYS: int = 7
ADJUSTMENT_AUTO_FIX: bool = True
ADJUSTMENT_CHECK_FULL_HISTORY: bool = True
```

---

## 9. 成功指標

| 指標 | 目標 |
|------|------|
| 検出精度 | 0.001%以上の乖離を100%検出 |
| 誤検出率 | 5%未満 |
| スキャン時間 | 100シンボル/5分以内 |
| 修正後の乖離 | < 0.0001% |
| イベント記録率 | 全検出イベントの100%を記録 |

---

## 10. 現行方式との比較

### 10.1 現行方式（corporate_events テーブルなし）

```
現在の実装:
┌─────────────────────────────────────────────────────────────┐
│  adjustment_detector.py                                     │
│  - 乖離検出 → メモリ上のScanResult/AdjustmentEventに格納    │
│  - 検出結果は一時的（APIレスポンスで返却後は消失）          │
│                                                             │
│  adjustment_fixer.py                                        │
│  - auto_fix_symbol(): 削除 → fetch_job作成                 │
│  - 修正履歴は fetch_jobs テーブルのみ                       │
└─────────────────────────────────────────────────────────────┘
```

### 10.2 メリット・デメリット比較

| 項目 | 現行方式 | 新方式（corporate_events追加） |
|------|----------|-------------------------------|
| **シンプルさ** | ✅ テーブル追加不要 | ❌ 新テーブル・マイグレーション必要 |
| **実装工数** | ✅ 既に完成 | ❌ 4.5日追加 |
| **DB負荷** | ✅ 追加書き込みなし | ⚠️ イベント毎にINSERT |
| **履歴追跡** | ❌ 不可能 | ✅ 完全に追跡可能 |
| **重複処理防止** | ❌ 同じ乖離を何度も検出 | ✅ UNIQUE制約で防止 |
| **監査証跡** | ❌ なし | ✅ 修正前後の状態を記録 |
| **分析機能** | ❌ 配当/分割履歴照会不可 | ✅ APIで照会可能 |
| **ETL連携** | ❌ 権利落ち日情報なし | ✅ ex_date等を提供可能 |
| **運用可視性** | ⚠️ ログのみ | ✅ ダッシュボード/API |
| **デバッグ** | ❌ 問題追跡困難 | ✅ イベント履歴で追跡 |

### 10.3 現行方式の具体的な問題点

#### 1. 重複スキャン問題
```python
# 毎回の週次スキャンで同じ乖離を検出
# 例: AAPLの2024-01配当 → 毎週「dividend」として検出
#     → 毎週「要修正」と報告される（実際は修正済みでも）
```

#### 2. 履歴消失問題
```python
# スキャン結果は ScanResult オブジェクト（メモリ上）
# APIレスポンス返却後は消失
# → 「先月何件修正したか」「どの銘柄で分割があったか」が不明
```

#### 3. 修正追跡の困難さ
```python
# adjustment_fixer.py の結果
result = {
    "symbol": "AAPL",
    "deleted_rows": 11023,
    "job_id": "abc12345",  # ← これだけが証跡
}
# fetch_jobs テーブルを見ても「なぜこのジョブが作られたか」不明
```

#### 4. ETL消費者への影響
```
現行:
- 消費者側で配当落ち日を知る手段がない
- 価格が急変した理由を判別できない

新方式:
GET /v1/events/AAPL?event_type=dividend
→ 配当履歴と権利落ち日を取得可能
→ 消費者側でリターン計算時に考慮可能
```

### 10.4 新方式が特に有効なケース

| ケース | 現行方式 | 新方式 |
|--------|----------|--------|
| 「先月の分割銘柄は？」 | ❌ 調査不可 | ✅ `GET /v1/events/splits?from=2024-11-01` |
| 「AAPLの配当履歴は？」 | ❌ yfinance再取得 | ✅ `GET /v1/events/AAPL?type=dividend` |
| 「修正が失敗した銘柄は？」 | ❌ ログ検索 | ✅ `GET /v1/events/pending?status=failed` |
| 「なぜこのfetch_jobが作られた？」 | ❌ 不明 | ✅ `corporate_events.fix_job_id` で紐付け |
| 「誤検出を除外したい」 | ❌ 毎回検出 | ✅ `status='ignored'` で除外 |

### 10.5 新方式のデメリット詳細

| デメリット | 影響 | 軽減策 |
|------------|------|--------|
| **実装工数** | 4.5日の追加開発 | 段階的実装（まずテーブルのみ） |
| **DB容量増加** | 1イベント≒200バイト | 年間数千件なら数MB |
| **書き込み負荷** | 検出毎にINSERT | バッチINSERTで軽減 |
| **複雑性増加** | コード・運用が複雑に | ドキュメント整備 |
| **マイグレーション** | 本番適用リスク | ステージングで検証 |

### 10.6 推奨判断

| 状況 | 推奨 |
|------|------|
| 個人利用・小規模 | 現行方式で十分 |
| **ETL連携あり** | **新方式を推奨** |
| **監査要件あり** | **新方式を推奨** |
| 運用可視性が重要 | 新方式を推奨 |
| 開発リソース限定 | 現行方式を継続 |

---

## 11. 次のアクション

1. **判断**: 新方式への移行要否を決定
2. **承認**: この設計書の内容を確認・承認
3. **実装開始**: Phase 1（マイグレーション）から着手
4. **テスト**: 単体テスト・統合テストの作成
5. **デプロイ**: ステージング環境での検証後、本番適用
