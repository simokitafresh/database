# パフォーマンス改善タスク (Speedup Tasks)

## 概要

現在のシステムのボトルネックを分析し、パフォーマンス改善のための具体的なタスクを定義します。
これらのタスクは、システムのスケーラビリティとレスポンスタイムを向上させることを目的としています。

## 主要ボトルネックと改善タスク

### 1. データベースクエリの非効率性 (N+1クエリ問題)

**問題**: `get_prices_resolved`関数でシンボルごとに個別クエリを実行
**影響**: 複数シンボルリクエスト時にN+1クエリ問題が発生

**タスク**: TASK-SPD-001
- **説明**: 複数シンボルを1つのクエリで処理するバッチクエリを実装
- **対象ファイル**: `app/db/queries.py`
- **受け入れ基準**:
  - `get_prices_resolved`関数が複数シンボルを1回のクエリで処理できる
  - パフォーマンステストでクエリ数が1/Nに削減されることを確認
  - 既存のAPI互換性を維持

### 2. 同期処理のスレッドプール使用

**問題**: yfinanceの同期APIを`run_in_threadpool`で非同期化
**影響**: スレッドプールのオーバーヘッドとGILによる並行性制限

**タスク**: TASK-SPD-002
- **説明**: aiohttpを使用した非同期HTTPクライアントを実装
- **対象ファイル**: `app/services/fetcher.py`, `requirements.txt`
- **受け入れ基準**:
  - yfinance依存を排除し、aiohttpベースの実装に置き換え
  - 並行性が向上し、スループットが2倍以上になることを確認
  - エラーハンドリングとリトライロジックを維持

### 3. アドバイザリロックによる並行性制限

**問題**: 各シンボルで`with_symbol_lock`を取得
**影響**: 同じシンボルの同時処理がブロックされる

**タスク**: TASK-SPD-003
- **説明**: Redisベースの分散ロックを実装
- **対象ファイル**: `app/db/utils.py`, `app/services/cache.py`
- **受け入れ基準**:
  - 同じシンボルの同時リクエストが可能になる
  - ロック競合が解消され、スループットが向上
  - Redis接続障害時のフォールバックを確保

### 4. 複雑なSQLクエリ

**問題**: `_get_coverage`関数でウィークデイギャップ検出に複雑なCTEを使用
**影響**: 大量データでのクエリ実行時間が長い

**タスク**: TASK-SPD-004
- **説明**: より効率的なSQLクエリとインデックス戦略を実装
- **対象ファイル**: `app/db/queries.py`, `migrations/`
- **受け入れ基準**:
  - クエリ実行時間が50%以上短縮される
  - 適切なデータベースインデックスが追加される
  - クエリプランの改善を確認

### 5. キャッシュチェックの非効率

**問題**: 各シンボルごとに個別にキャッシュをチェック
**影響**: Redisなどの外部キャッシュへの複数ラウンドトリップ

**タスク**: TASK-SPD-005
- **説明**: 複数シンボルのキャッシュをバッチでチェックするロジックを実装
- **対象ファイル**: `app/services/cache.py`, `app/api/v1/prices.py`
- **受け入れ基準**:
  - キャッシュチェックのネットワークラウンドトリップが1回になる
  - キャッシュヒット率が向上
  - Redisのパイプライン機能を使用

### 6. 外部API依存とレート制限

**問題**: yfinance APIのレート制限（`YF_REQ_CONCURRENCY=8`）
**影響**: 大量シンボル処理時の遅延と429エラー

**タスク**: TASK-SPD-006
- **説明**: より洗練されたレート制限メカニズムを実装
- **対象ファイル**: `app/services/fetcher.py`, `app/core/config.py`
- **受け入れ基準**:
  - レート制限エラーが50%以上減少
  - 指数バックオフとトークンバケットアルゴリズムを実装
  - 設定可能なレート制限パラメータ

### 7. メモリ使用量の増大

**問題**: 大量のDataFrame処理と中間結果の保持
**影響**: 大規模リクエスト時のメモリ不足

**タスク**: TASK-SPD-007
- **説明**: ストリーミング処理とメモリ効率の良いデータ処理を実装
- **対象ファイル**: `app/services/fetcher.py`, `app/services/upsert.py`
- **受け入れ基準**:
  - 大規模リクエスト時のメモリ使用量が50%削減
  - pandas DataFrameのチャンク処理を実装
  - OOMエラーが解消される

### 8. 自動登録の逐次処理

**問題**: シンボル検証を1つずつ実行
**影響**: 新規シンボル追加時の遅延

**タスク**: TASK-SPD-008
- **説明**: シンボル検証を並行処理化
- **対象ファイル**: `app/services/auto_register.py`, `app/api/v1/prices.py`
- **受け入れ基準**:
  - 複数シンボルの検証時間が1/Nに短縮
  - 適切な並行性制御を実装
  - エラーハンドリングを維持

### 9. 設定値の最適化

**問題**: `API_MAX_ROWS=1000000`など過度に大きい上限
**影響**: DoS攻撃の可能性とリソース枯渇

**タスク**: TASK-SPD-009
- **説明**: より現実的な設定値と動的制限を実装
- **対象ファイル**: `app/core/config.py`, `app/api/v1/prices.py`
- **受け入れ基準**:
  - 設定値が現実的な値に調整される
  - リクエストサイズに基づく動的制限を実装
  - セキュリティとパフォーマンスのバランス

### 10. エラーハンドリングの最適化

**問題**: 多重リトライとフォールバックロジック
**影響**: コードの保守性低下とデバッグの難しさ

**タスク**: TASK-SPD-010
- **説明**: 効率的なエラーハンドリングとリトライ戦略を実装
- **対象ファイル**: `app/services/fetcher.py`, `app/core/logging.py`
- **受け入れ基準**:
  - リトライロジックが簡素化され、効率的になる
  - エラーメトリクスが適切に収集される
  - デッドラインとタイムアウトが適切に設定される

## 実装順序の推奨

1. **TASK-SPD-001**: データベースクエリの改善（最大の影響）
2. **TASK-SPD-002**: 非同期HTTPクライアント（基盤改善）
3. **TASK-SPD-004**: SQLクエリ最適化（即時効果）
4. **TASK-SPD-005**: キャッシュ最適化（低コストで効果的）
5. **TASK-SPD-007**: メモリ最適化（安定性向上）
6. **TASK-SPD-003**: 分散ロック（並行性向上）
7. **TASK-SPD-006**: レート制限（信頼性向上）
8. **TASK-SPD-008**: 自動登録並行化（UX改善）
9. **TASK-SPD-009**: 設定最適化（セキュリティ）
10. **TASK-SPD-010**: エラーハンドリング（保守性）

## 測定基準

各タスクの実装後、以下のメトリクスで改善効果を測定：

- **レスポンスタイム**: APIエンドポイントの平均/95パーセンタイル応答時間
- **スループット**: 1秒あたりのリクエスト処理数
- **メモリ使用量**: ピーク時メモリ使用量
- **データベース接続数**: 同時接続数とクエリ実行時間
- **エラー率**: 5xxエラーの割合

## テスト戦略

- **パフォーマンステスト**: locustまたはk6を使用した負荷テスト
- **統合テスト**: 既存テストスイートの拡張
- **負荷テスト**: 段階的な負荷増加によるボトルネック特定
- **A/Bテスト**: 本番環境での段階的ロールアウト

---

*このタスク定義は、現在のコード分析に基づいています。実装前に再度プロファイリングを行い、優先順位を調整することを推奨します。*